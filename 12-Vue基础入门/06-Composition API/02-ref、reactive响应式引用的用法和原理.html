<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Document</title>
		<style></style>
		<script src="https://cdn.jsdelivr.net/npm/vue@3.2.47/dist/vue.global.min.js"></script>
	</head>
	<body>
		<!-- 挂载点 -->
		<div id="root"></div>
	</body>
	<script>
		// 创建 Vue 实例
		const app = Vue.createApp({
			// 根组件
			template: `
				<div @click="handleClick">{{name}}{{xk}}{{age}}</div>
			`,
			// created 实例被完全初始化之前执行
			setup(props, context) {
				// 响应式API

				// ref() 接受一个内部值，返回一个响应式的、可更改的 ref 对象，此对象只有一个指向其内部值的属性 .value。
				const { ref } = Vue;
				const name = ref('xk'); // 推荐使用 ref 处理基础类型
				setTimeout(() => {
					name.value = 'xk347';
				}, 1000);

				// reactive()​ 返回一个对象的响应式代理。
				const { reactive } = Vue;
				// 推荐使用 reactive 代理对象 数组等
				const xk = reactive({
					name: 'xk',
					age: 30,
				});
				setTimeout(() => {
					xk.age = 31;
				}, 1000);

				// readonly()​ 接受一个对象 (不论是响应式还是普通的) 或是一个 ref，返回一个原值的只读代理。
				const { readonly } = Vue;
				const onlyRead = readonly(name);
				setTimeout(() => {
					onlyRead.value = 'xk443'; // 更改该只读副本将会失败，并会得到一个警告
				}, 2000);

				// const { age } = xk; // 解构后的数据不具有响应性
				const { toRefs } = Vue;
				const { age } = toRefs(xk); // 将一个响应式对象转换为一个普通对象，这个普通对象的每个属性都是指向源对象相应属性的 ref。
				return { name, xk, age };
			},
		});

		const vm = app.mount('#root');
	</script>
</html>
