<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Document</title>
		<style></style>
		<script src="https://cdn.jsdelivr.net/npm/vue@3.2.47/dist/vue.global.min.js"></script>
	</head>
	<body>
		<!-- 挂载点 -->
		<div id="root"></div>
	</body>
	<script>
		// 创建 Vue 实例
		const app = Vue.createApp({
			// 根组件
			template: `
				<div>
					<div>input: <input v-model="name" /></div>
					<div>name is {{name}}</div>
                </div>
				<div>
					<div>input: <input v-model="age" /></div>
					<div>age is {{age}}</div>
                </div>
			`,
			// 组合式 API 的入口
			setup(props, context) {
				const { ref, reactive, toRefs, toRef, watch, watchEffect } = Vue;
				const obj = reactive({
					name: 'xk',
					age: 30,
				});

				const { name, age } = toRefs(obj);
				// const name = toRef(obj, 'name');

				// watch 默认是懒执行的：仅当数据源变化时，才会执行回调。
				watch(
					[() => obj.name, () => obj.age], // [obj1,obj2] 侦听多个数据源
					([currNameValue, currAgeValue], [prevNameValue, prevAgeValue]) => {
						console.log('watch');
						console.log(currNameValue, prevNameValue);
						console.log(currAgeValue, prevAgeValue);
					},
					// 可以通过传入 immediate: true 选项来强制侦听器的回调立即执行
					{ immediate: true }
				);

				// watchEffect 会在同步执行过程中，自动追踪所有能访问到的响应式属性。
				const todoId = ref(1);
				const data = ref(null);
				watchEffect(async () => {
					/**
					 * 这个例子中，回调会立即执行，不需要指定 immediate: true。
					 * 在执行期间，它会自动追踪 todoId.value 作为依赖（和计算属性类似）。
					 * 每当 todoId.value 变化时，回调会再次执行。
					 * 有了 watchEffect()，我们不再需要明确传递 todoId 作为源值。
					 **/

					// 如果你需要侦听一个嵌套数据结构中的几个属性，watchEffect() 可能会比深度侦听器更有效，
					// 因为它将只跟踪回调中被使用到的属性，而不是递归地跟踪所有的属性。
					const response = await fetch(
						`https://jsonplaceholder.typicode.com/todos/${todoId.value}`
					);
					// watchEffect 仅会在其同步执行期间，才追踪依赖。
					// 在使用异步回调时，只有在第一个 await 正常工作前访问到的属性才会被踪。
					data.value = await response.json();
					console.log(data.value);
				});

				watchEffect(() => {
					console.log('watchEffect', obj.name, obj.age);
				});

				/**
				 * 要手动停止一个侦听器，请调用 watch 或 watchEffect 返回的函数：
				 * const unwatch = watchEffect(() => {})
				 *  ...当该侦听器不再需要时
				 * unwatch()
				 **/

				return {
					name,
					age,
				};
			},
		});

		const vm = app.mount('#root');
	</script>
</html>
